from __future__ import annotations

from enum import Enum
from typing import Any, Iterable, Iterator, List, Mapping, Optional, Tuple, Union

# Public module API (manually authored for v1)

# ---- Convenience functions ----
class FormulaDialect(Enum):
    Excel = ...
    OpenFormula = ...

# Back-compat with the pyo3-stubgen naming.
PyFormulaDialect = FormulaDialect

class WorkbookMode(Enum):
    Ephemeral = ...
    Interactive = ...

class WorkbookConfig:
    def __init__(
        self,
        *,
        mode: WorkbookMode = ...,
        eval_config: Optional[EvaluationConfig] = ...,
        enable_changelog: Optional[bool] = ...,
    ) -> None: ...

def tokenize(formula: str, dialect: Optional[FormulaDialect] = None) -> Tokenizer: ...
def parse(formula: str, dialect: Optional[FormulaDialect] = None) -> ASTNode: ...
def load_workbook(path: str, strategy: Optional[str] = None) -> Workbook: ...

# ---- Tokenizer / Token ----
class TokenType(Enum):
    Literal = ...
    Operand = ...
    Func = ...
    Array = ...
    Paren = ...
    Sep = ...
    OpPrefix = ...
    OpInfix = ...
    OpPostfix = ...
    Whitespace = ...

class TokenSubType(Enum):
    None_ = ...
    Text = ...
    Number = ...
    Logical = ...
    Error = ...
    Range = ...
    Open = ...
    Close = ...
    Arg = ...
    Row = ...

class Token:
    @property
    def value(self) -> str: ...
    @property
    def token_type(self) -> TokenType: ...
    @property
    def subtype(self) -> TokenSubType: ...
    @property
    def start(self) -> int: ...
    @property
    def end(self) -> int: ...
    def to_dict(self) -> dict: ...
    def is_operator(self) -> bool: ...
    def get_precedence(self) -> Optional[Tuple[int, str]]: ...

class Tokenizer(Iterable[Token]):
    def __init__(
        self, formula: str, dialect: Optional[FormulaDialect] = None
    ) -> None: ...
    def tokens(self) -> List[Token]: ...
    def render(self) -> str: ...
    @property
    def dialect(self) -> FormulaDialect: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Token: ...
    def __iter__(self) -> Iterator[Token]: ...

class TokenizerIter(Iterator[Token]):
    def __iter__(self) -> TokenizerIter: ...
    def __next__(self) -> Token: ...

# ---- AST ----
class ASTNode:
    def pretty(self) -> str: ...
    def to_formula(self) -> str: ...
    def fingerprint(self) -> int: ...
    def children(self) -> List[ASTNode]: ...
    def walk_refs(self) -> RefWalker: ...
    def to_dict(self) -> Any: ...
    def node_type(self) -> str: ...
    def get_literal_value(self) -> Optional[Any]: ...
    def get_reference_string(self) -> Optional[str]: ...
    def get_reference(self) -> Optional[ReferenceLike]: ...
    def get_operator(self) -> Optional[str]: ...
    def get_function_name(self) -> Optional[str]: ...
    def get_source_token(self) -> Optional[Token]: ...

class RefWalker(Iterator[ReferenceLike]):
    def __iter__(self) -> RefWalker: ...
    def __next__(self) -> ReferenceLike: ...

# ---- Literal values ----
class LiteralValue:
    # Constructors
    @staticmethod
    def int(value: int) -> LiteralValue: ...
    @staticmethod
    def number(value: float) -> LiteralValue: ...
    @staticmethod
    def boolean(value: bool) -> LiteralValue: ...
    @staticmethod
    def text(value: str) -> LiteralValue: ...
    @staticmethod
    def empty() -> LiteralValue: ...
    @staticmethod
    def date(year: int, month: int, day: int) -> LiteralValue: ...
    @staticmethod
    def time(hour: int, minute: int, second: int) -> LiteralValue: ...
    @staticmethod
    def datetime(
        year: int, month: int, day: int, hour: int, minute: int, second: int
    ) -> LiteralValue: ...
    @staticmethod
    def duration(seconds: int) -> LiteralValue: ...
    @staticmethod
    def array(values: List[List[LiteralValue]]) -> LiteralValue: ...
    @staticmethod
    def error(kind: str, message: Optional[str] = None) -> LiteralValue: ...

    # Extractors
    def as_int(self) -> int: ...
    def as_number(self) -> float: ...
    def to_python(self) -> Any: ...

    # Introspection
    @property
    def type_name(self) -> str: ...
    @property
    def is_int(self) -> bool: ...
    @property
    def is_number(self) -> bool: ...
    @property
    def is_boolean(self) -> bool: ...
    @property
    def is_text(self) -> bool: ...
    @property
    def is_empty(self) -> bool: ...
    @property
    def is_date(self) -> bool: ...
    @property
    def is_time(self) -> bool: ...
    @property
    def is_datetime(self) -> bool: ...
    @property
    def is_duration(self) -> bool: ...
    @property
    def is_array(self) -> bool: ...
    @property
    def is_error(self) -> bool: ...
    @property
    def is_pending(self) -> bool: ...
    @property
    def error_kind(self) -> Optional[str]: ...
    @property
    def error_message(self) -> Optional[str]: ...
    @property
    def error_location(self) -> Optional[Tuple[int, int]]: ...
    @property
    def error_origin(self) -> Optional[Tuple[Optional[str], int, int]]: ...

# ---- Workbook / Sheet ----
class Cell:
    @property
    def value(self) -> Any: ...
    @property
    def formula(self) -> Optional[str]: ...

class RangeAddress:
    def __init__(
        self, sheet: str, start_row: int, start_col: int, end_row: int, end_col: int
    ) -> None: ...

class Sheet:
    name: str
    def set_value(self, row: int, col: int, value: Any) -> None: ...
    def set_formula(self, row: int, col: int, formula: str) -> None: ...
    def get_cell(self, row: int, col: int) -> Cell: ...
    def set_values_batch(
        self,
        start_row: int,
        start_col: int,
        rows: int,
        cols: int,
        data: List[List[Any]],
    ) -> None: ...
    def set_formulas_batch(
        self,
        start_row: int,
        start_col: int,
        rows: int,
        cols: int,
        formulas: List[List[str]],
    ) -> None: ...
    def get_values(self, range: RangeAddress) -> List[List[Any]]: ...
    def get_formulas(self, range: RangeAddress) -> List[List[str]]: ...

class Workbook:
    def __init__(
        self,
        *,
        mode: Optional[WorkbookMode] = ...,
        config: Optional[WorkbookConfig] = ...,
    ) -> None: ...
    @classmethod
    def from_path(
        cls,
        path: str,
        backend: Optional[str] = None,
        *,
        mode: Optional[WorkbookMode] = ...,
        config: Optional[WorkbookConfig] = ...,
    ) -> Workbook: ...
    @classmethod
    def load_path(
        cls,
        path: str,
        strategy: Optional[str] = None,
        backend: Optional[str] = None,
        *,
        mode: Optional[WorkbookMode] = ...,
        config: Optional[WorkbookConfig] = ...,
    ) -> Workbook: ...
    def add_sheet(self, name: str) -> None: ...
    @property
    def sheet_names(self) -> List[str]: ...
    def sheet(self, name: str) -> Sheet: ...
    def __getitem__(self, name: str) -> Sheet: ...
    # Single cell ops
    def set_value(self, sheet: str, row: int, col: int, value: Any) -> None: ...
    def set_formula(self, sheet: str, row: int, col: int, formula: str) -> None: ...
    def get_value(self, sheet: str, row: int, col: int) -> Optional[Any]: ...
    def get_formula(self, sheet: str, row: int, col: int) -> Optional[str]: ...
    def evaluate_cell(self, sheet: str, row: int, col: int) -> Any: ...
    # Batch ops (autoâ€‘grouped when changelog enabled)
    def set_values_batch(
        self, sheet: str, start_row: int, start_col: int, data: List[List[Any]]
    ) -> None: ...
    def set_formulas_batch(
        self, sheet: str, start_row: int, start_col: int, formulas: List[List[str]]
    ) -> None: ...
    def get_eval_plan(self, targets: List[Tuple[str, int, int]]) -> EvaluationPlan: ...
    # Changelog controls (optional)
    def set_changelog_enabled(self, enabled: bool) -> None: ...
    def begin_action(self, description: str) -> None: ...
    def end_action(self) -> None: ...
    def undo(self) -> None: ...
    def redo(self) -> None: ...

# ---- SheetPort ----
class SheetPortError(Exception): ...
class SheetPortManifestError(SheetPortError): ...
class SheetPortConstraintError(SheetPortError): ...
class SheetPortWorkbookError(SheetPortError): ...

class SheetPortSession:
    @classmethod
    def from_manifest_path(
        cls,
        manifest_path: str,
        workbook_path: str,
        backend: Optional[str] = None,
    ) -> SheetPortSession: ...
    @classmethod
    def from_manifest_yaml(
        cls, manifest_yaml: str, workbook: Workbook
    ) -> SheetPortSession: ...
    @property
    def manifest(self) -> Mapping[str, Any]: ...
    def describe_ports(self) -> List[Mapping[str, Any]]: ...
    def read_inputs(self) -> Mapping[str, Any]: ...
    def read_outputs(self) -> Mapping[str, Any]: ...
    def write_inputs(self, update: Mapping[str, Any]) -> None: ...
    def evaluate_once(
        self,
        *,
        freeze_volatile: bool = ...,
        rng_seed: Optional[int] = ...,
    ) -> Mapping[str, Any]: ...

class EvaluationConfig:
    def __init__(self) -> None: ...
    # Common toggles
    def set_enable_parallel(self, value: bool) -> None: ...
    def get_enable_parallel(self) -> bool: ...
    def set_max_threads(self, value: Optional[int]) -> None: ...
    def get_max_threads(self) -> Optional[int]: ...
    def set_range_expansion_limit(self, value: int) -> None: ...
    def get_range_expansion_limit(self) -> int: ...
    def set_workbook_seed(self, value: int) -> None: ...
    def get_workbook_seed(self) -> int: ...
    # Warmup subset
    def set_warmup_enabled(self, value: bool) -> None: ...
    def get_warmup_enabled(self) -> bool: ...
    def set_warmup_time_budget_ms(self, value: int) -> None: ...
    def get_warmup_time_budget_ms(self) -> int: ...
    def set_warmup_parallelism_cap(self, value: int) -> None: ...
    def get_warmup_parallelism_cap(self) -> int: ...
    def set_warmup_topk_refs(self, value: int) -> None: ...
    def get_warmup_topk_refs(self) -> int: ...
    def set_min_flat_cells(self, value: int) -> None: ...
    def get_min_flat_cells(self) -> int: ...
    def set_flat_cache_mb_cap(self, value: int) -> None: ...
    def get_flat_cache_mb_cap(self) -> int: ...
    def get_date_system(self) -> str: ...
    def set_date_system(self, value: str) -> None: ...

class LayerInfo:
    @property
    def vertex_count(self) -> int: ...
    @property
    def parallel_eligible(self) -> bool: ...
    @property
    def sample_cells(self) -> List[str]: ...

class EvaluationPlan:
    @property
    def total_vertices_to_evaluate(self) -> int: ...
    @property
    def layers(self) -> List[LayerInfo]: ...
    @property
    def cycles_detected(self) -> int: ...
    @property
    def dirty_count(self) -> int: ...
    @property
    def volatile_count(self) -> int: ...
    @property
    def parallel_enabled(self) -> bool: ...
    @property
    def estimated_parallel_layers(self) -> int: ...
    @property
    def target_cells(self) -> List[str]: ...

# ---- References (types and union) ----
class CellRef:
    sheet: Optional[str]
    row: int
    col: int
    abs_row: bool
    abs_col: bool
    def __init__(
        self,
        sheet: Optional[str],
        row: int,
        col: Union[int, str],
        abs_row: bool = True,
        abs_col: bool = True,
    ) -> None: ...
    @classmethod
    def from_string(
        cls, reference: str, default_sheet: Optional[str] = None
    ) -> CellRef: ...
    @property
    def str_col(self) -> str: ...

class RangeRef:
    sheet: Optional[str]
    start: Optional[CellRef]
    end: Optional[CellRef]
    def __init__(
        self, sheet: Optional[str], start: Optional[CellRef], end: Optional[CellRef]
    ) -> None: ...

class TableRef:
    name: str
    spec: Optional[str]
    def __init__(self, name: str, spec: Optional[str]) -> None: ...

class NamedRangeRef:
    name: str
    def __init__(self, name: str) -> None: ...

class UnknownRef:
    raw: str
    def __init__(self, raw: str) -> None: ...

ReferenceLike = Union[CellRef, RangeRef, TableRef, NamedRangeRef, UnknownRef]

# Back-compat aliases for the internal pyo3 types.
PyToken = Token
PyTokenizer = Tokenizer
PyTokenizerIter = TokenizerIter
PyRefWalker = RefWalker
PyTokenType = TokenType
PyTokenSubType = TokenSubType
